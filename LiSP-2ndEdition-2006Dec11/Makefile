# Makefile generated by imake - do not edit!
# $Xorg: imake.c,v 1.6 2001/02/09 02:03:15 xorgcvs Exp $

default.work : build.interpreter

# # $Id: Site.def,v 1.6 2005/07/17 15:55:21 queinnec Exp $

# ###(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
# ### This file is part of the files that accompany the book:
# ###     LISP Implantation Semantique Programmation (InterEditions, France)
# ### By Christian Queinnec <Christian.Queinnec@INRIA.fr>
# ### Newest version may be retrieved from:
# ###   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
# ### Check the README file before using this file.
# ###(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

# # If you decide to build a specialized interpreter on top of Bigloo
# # then indicate the correct command to invoke bigloo.

BIGLOO		= bigloo

# # If you decide to build a specialized interpreter on top of Scheme->C
# # then indicate the correct command to invoke the Scheme->C compiler

SCC		= scc

# # If you decide to build multiple specialized interpreters on multiple
# # machines, then you must give different HOSTTYPE for all these
# # CPU-different machines. Very often, HOSTTYPE is set up for you by your
# # shell (tcsh does this), at that time, you can leave empty this
# # definition, it will be automatically inherited from your shell.

HOSTTYPE	= YourCpuType

# # Choose a Scheme interpreter. This interpreter must contain Meroonet,
# # hygienic macros and a test-suite driver. It is better to build a
# # specialized interpreter with these facilities compiled in, see entries
# # o/${HOSTTYPE}/book.{bigloo,sci} below to regenerate them. You can
# # also directly use an interpreter and load on the fly Meroonet, hygienic
# # macros and the like every time. This is what the SCM-based definition
# # or the Gambit (gsi) based definition does.

# #SCHEME	=	o/${HOSTTYPE}/book.sci
# #SCHEME	=	o/${HOSTTYPE}/book.bigloo
# #SCHEME	=	"gsi '(include \"gambit/book.scm\")' "

# # Scm 4e1 is perfect here. This command is intended to be run in the
# # current directory only.
SCHEME		= scm -u -l scm/Init.scm

# # This variable allows to measure time.
# # I personnally use Gnu time but time will do also.

TIME		= time

# # This is the make utility. You can use Gnu make or others, I paid
# # attention not to use advanced features.

MAKE		= make

# # A temporary file used to store temporary results. Put it in a place
# # where it will disappear automatically sometime.

RESULTS		= /tmp/result

# # Make an archive grouping *.o files
# # You need it if you want to test the Scheme towards C compiler.

AR      = ar

# # Updating an archive (void on some machines)
# # You need it if you want to test the Scheme towards C compiler.

RANLIB  = ranlib

# # This is the C compiler I used as well as its preferred flags.
# # You need it if you want to test the Scheme towards C compiler.

CC      = gcc
CFLAGS  = -ansi -pedantic -Wall -O

# # This is perl. I use it for checking results of tests. It is not
# # mandatory to setup this variable.

PERL =  perl

# # end of Site.def

# $Id: Dist.Imakefile,v 4.0 1995/07/10 06:49:47 queinnec Exp $

# ##(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
# ## This file is part of the files that accompany the book:
# ##     LISP Implantation Semantique Programmation (InterEditions, France)
# ## By Christian Queinnec <Christian.Queinnec@INRIA.fr>
# ## Newest version may be retrieved from:
# ##   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
# ## Check the README file before using this file.
# ##(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

# This is the Imakefile of the distribution.
# The first part defines the variables that you may have to setup in
# order to run the tests. The second part defines how to test the various
# parts of the sourcef files.

# # $Id: Test.mkf,v 4.8 2005/07/17 15:54:04 queinnec Exp $

# ###(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
# ### This file is part of the files that accompany the book:
# ###     LISP Implantation Semantique Programmation (InterEditions, France)
# ### By Christian Queinnec <Christian.Queinnec@INRIA.fr>
# ### Newest version may be retrieved from:
# ###   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
# ### Check the README file before using this file.
# ###(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

# # This part of the global Imakefile defines how to run and test the
# # programs of the book.
# # When tests are time-consuming, the time is indicated (measured on my
# # machine: a Sony workstation with a R3000 processor). Tests range from
# # a few seconds to a few hours!

# ##################################### Build specialized interpreters.
# # Rebuild a Scheme->C interpreter with a compiled Meroonet in it. It also
# # contains tester and syntax-case. This takes roughly 8 minutes on my
# # machine.

o/${HOSTTYPE}/book.sci : scheme2c/book.sc 		scheme2c/others/compat.ss 			scheme2c/others/expand.sc			scheme2c/others/hooks.sc			scheme2c/others/init.ss				scheme2c/others/macro-defs.sc			scheme2c/others/output.ss

	-[ -d o/${HOSTTYPE} ] || ${MAKE} mkdir
	${SCC} -o o/${HOSTTYPE}/book.sci scheme2c/book.sc
	-rm scheme2c/book.[co] scheme2c/book.S2C

# # Rebuild a Bigloo interpreter with Meroonet, tester and syntax-case in it.
# # This takes roughly 7 minutes (elapsed time) on my machine.
# # expand.bb and macro-defs.bb files are taken from ~/scm/syntax-caseV2.0
# # except that the two last functions (make-promise and force) from
# # macro-defs.bb are commented by hand not to redefine those of Bigloo.

# # Adapted to Bigloo 1.9d (no need to compile with -hygien but must
# # run with hygien? set to true). Due to name conflicts, the compilation
# # of rtbook.bgl emits much warnings: ignore them!

LiSP4bigloo19d.distribution : LiSP4bigloo19d.tar.gz
	mv LiSP4bigloo19d.tar.gz `date +LiSP4bigloo19d-%y%h%d.tgz`
LiSP4bigloo19d.tar.gz : LiSP4bigloo19d.tar
	gzip LiSP4bigloo19d.tar
LiSP4bigloo19d.tar :
	tar -cvhf LiSP4bigloo19d.tar --exclude RCS 		README.LiSP4bigloo19d Test.mkf bigloo src/tester.scm meroonet

o/${HOSTTYPE}/book.bigloo : bigloo/book.bgl o/${HOSTTYPE}/rtbook.a
	${BIGLOO} -v -call/cc -cg -o o/${HOSTTYPE}/book.bigloo 		bigloo/book.bgl -ldopt o/${HOSTTYPE}/rtbook.a

	-rm bigloo/book.[co] o/${HOSTTYPE}/book.[co]

o/${HOSTTYPE}/rtbook.a : o/${HOSTTYPE}/rtbook.o
o/${HOSTTYPE}/rtbook.a : o/${HOSTTYPE}/rtbook+.o
	-rm o/${HOSTTYPE}/rtbook.a
	cd o/${HOSTTYPE} ; ${AR} cvr rtbook.a rtbook.o rtbook+.o
	-${RANLIB} o/${HOSTTYPE}/rtbook.a

o/${HOSTTYPE}/rtbook.o : bigloo/rtbook.bgl 			bigloo/others/compat.ss 			bigloo/others/hooks.bgl				bigloo/others/output.ss				bigloo/others/init.ss				bigloo/others/expand.bb				bigloo/others/macro-defs.bb			bigloo/hack.bgl 				src/tester.scm

	-[ -d o/${HOSTTYPE} ] || ${MAKE} mkdir
	${BIGLOO} -c -v -call/cc -cg -w                 -o o/${HOSTTYPE}/rtbook.o bigloo/rtbook.bgl

	-rm bigloo/rtbook.[co] o/${HOSTTYPE}/rtbook.c

o/${HOSTTYPE}/rtbook+.o : bigloo/rtbook+.bgl 			bigloo/others/pp.scm				bigloo/others/format.scm

	-[ -d o/${HOSTTYPE} ] || ${MAKE} mkdir
	${BIGLOO} -c -v -call/cc -cg                 -o o/${HOSTTYPE}/rtbook+.o bigloo/rtbook+.bgl

	-rm bigloo/rtbook+.[co]  o/${HOSTTYPE}/rtbook+.c

# # Default work for the distribution, create some sub-directories
# # where will go compilation products.
build.interpreter : mkdir
	@if [ "X${SCHEME}" = X ] ;	then echo "*** Unbound SCHEME variable, see Makefile" ; exit 1 ;	else : ; fi

	case "${SCHEME}" in *bigloo|*scc) ${MAKE} ${SCHEME} ;; *) : ;; esac

# ######################################## Test interpreters

test.interpreters :	o/${HOSTTYPE}/book.sci.test				o/${HOSTTYPE}/book.bigloo.test				o/${HOSTTYPE}/book.scm.test

# # Makes a command for SCM similar to the others. This command has to be
# # run from the current directory.
o/${HOSTTYPE}/book.scm :
	echo "exec scm -u -l scm/Init.scm" > o/${HOSTTYPE}/book.scm
	chmod a=rx o/${HOSTTYPE}/book.scm

# # Makes a command for Elk. Must be run from the current directory.
# # You must load elk/book.elk by hand.
o/${HOSTTYPE}/book.elk :
	echo "(echo '(load \"elk/book.elk\")' ; tee ) | exec elk -i -h 5000" > o/${HOSTTYPE}/book.elk
	chmod a=rx o/${HOSTTYPE}/book.elk

# # Makes a command to run mitscheme. Must be run from the current directory.
o/${HOSTTYPE}/book.mit :
	echo done.

# # Makes a command for Gambit interpreter similar to the others.
# # This command has to be run from the current directory.
o/${HOSTTYPE}/book.gsi :
	echo "exec gsi '(include \"gambit/book.scm\")'" > o/${HOSTTYPE}/book.gsi
	chmod a=rx o/${HOSTTYPE}/book.gsi

# # Compile for Gambit
# # Gambit rules to find files are relative to previous ones (as in Mac)
# # so change pathnames to absolute pathnames. Takes five hours on my
# # old Sony.
o/${HOSTTYPE}/book-gsc.scm : gambit/book.scm
	sed -e "s;include \";include \"`pwd`/;" < gambit/book.scm 		> o/${HOSTTYPE}/book-gsc.scm

o/${HOSTTYPE}/book-gsc.escm : o/${HOSTTYPE}/book-gsc.scm gambit/hooks.gsi
	cd o/${HOSTTYPE} ; 		gsc -:h20000 -expansion book-gsc.scm 			> book-gsc.escm

	more o/${HOSTTYPE}/book-gsc.escm
o/${HOSTTYPE}/book-gsc.c : o/${HOSTTYPE}/book-gsc.scm gambit/hooks.gsi
	cd o/${HOSTTYPE} ; 		gsc -:h20000 -link -verbose -report book-gsc.scm

o/${HOSTTYPE}/book-gsc.o : o/${HOSTTYPE}/book-gsc.c
	cd o/${HOSTTYPE} ; gcc -c book-gsc.c
o/${HOSTTYPE}/book-gsc_.o : o/${HOSTTYPE}/book-gsc.c
	cd o/${HOSTTYPE} ; gcc -c book-gsc_.c
o/${HOSTTYPE}/book.gsc : o/${HOSTTYPE}/book-gsc.o
o/${HOSTTYPE}/book.gsc : o/${HOSTTYPE}/book-gsc_.o
	cd o/${HOSTTYPE} ; gcc -o book.gsc book-gsc.o book-gsc_.o 		-lgambc -lm

check.results :
	@if grep -i '= done' ${RESULTS} ; 					then echo '*** Tests successfully passed ***' ;				else echo '*** *** Abnormal results **** ***' ; exit 1 ; fi

o/${HOSTTYPE}/book.sci.test : o/${HOSTTYPE}/book.sci.test1
o/${HOSTTYPE}/book.sci.test : o/${HOSTTYPE}/book.sci.test2
o/${HOSTTYPE}/book.sci.test : o/${HOSTTYPE}/book.sci.test3
o/${HOSTTYPE}/book.sci.test : o/${HOSTTYPE}/book.sci.test4
o/${HOSTTYPE}/book.sci.test1 : o/${HOSTTYPE}/book.sci
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.sci	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.sci.test2 : o/${HOSTTYPE}/book.sci
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.sci		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.sci.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.sci test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.sci.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.sci test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test1
o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test2
o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test3
o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test4
o/${HOSTTYPE}/book.bigloo.test1 : o/${HOSTTYPE}/book.bigloo
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.bigloo	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.bigloo.test2 : o/${HOSTTYPE}/book.bigloo
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.bigloo		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.bigloo.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.bigloo test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.bigloo.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.bigloo test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.scm.test : o/${HOSTTYPE}/book.scm.test1
o/${HOSTTYPE}/book.scm.test : o/${HOSTTYPE}/book.scm.test2
o/${HOSTTYPE}/book.scm.test : o/${HOSTTYPE}/book.scm.test3
o/${HOSTTYPE}/book.scm.test : o/${HOSTTYPE}/book.scm.test4
o/${HOSTTYPE}/book.scm.test1 : o/${HOSTTYPE}/book.scm
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.scm	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.scm.test2 : o/${HOSTTYPE}/book.scm
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.scm		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.scm.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.scm test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.scm.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.scm test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.elk.test : o/${HOSTTYPE}/book.elk.test1
o/${HOSTTYPE}/book.elk.test : o/${HOSTTYPE}/book.elk.test2
o/${HOSTTYPE}/book.elk.test : o/${HOSTTYPE}/book.elk.test3
o/${HOSTTYPE}/book.elk.test : o/${HOSTTYPE}/book.elk.test4
o/${HOSTTYPE}/book.elk.test1 : o/${HOSTTYPE}/book.elk
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.elk	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.elk.test2 : o/${HOSTTYPE}/book.elk
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.elk		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.elk.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.elk test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.elk.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.elk test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test1
o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test2
o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test3
o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test4
o/${HOSTTYPE}/book.gsi.test1 : o/${HOSTTYPE}/book.gsi
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.gsi	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsi.test2 : o/${HOSTTYPE}/book.gsi
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.gsi		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsi.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsi test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsi.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsi test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test1
o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test2
o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test3
o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test4
o/${HOSTTYPE}/book.gsc.test1 : o/${HOSTTYPE}/book.gsc
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.gsc	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsc.test2 : o/${HOSTTYPE}/book.gsc
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.gsc		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsc.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsc test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsc.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsc test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test1
o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test2
o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test3
o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test4
o/${HOSTTYPE}/book.mit.test1 : o/${HOSTTYPE}/book.mit
	echo "(test \"bigloo/others/syntax.tst\")" | o/${HOSTTYPE}/book.mit	\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.mit.test2 : o/${HOSTTYPE}/book.mit
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.mit		\
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.mit.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.mit test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.mit.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.mit test.chap2a | tee ${RESULTS}
	${MAKE} check.results

# ######################################## Utility entries
# # Build the necessary directories where will go specialized interpreters.
mkdir :
	-[ -d o ] || mkdir o
	-[ -d o/${HOSTTYPE} ] || mkdir o/${HOSTTYPE}
clean :: ;	-rm -rf o/${HOSTTYPE}

tags : TAGS
TAGS :
	etags src/?*.scm

# ########################## All the tests
# # Some tests have a name starting with no. That means that the test
# # has some problems (it does not complete or loops) I just verify that
# # it ends at the expected point. Some test have a name starting with
# # long. That means that it is a very long long test (hours!) so it is
# # only run if the variable YOU_HAVE_TIME is true (not false).

YOU_HAVE_TIME	=	false

GRAND_TESTS =	${TEST_CHAP1}			${TEST_CHAP2}			${TEST_CHAP3}			${TEST_CHAP4}			${TEST_CHAP5}			${TEST_CHAP6}			${TEST_CHAP7}			${TEST_CHAP8}			${TEST_CHAP9}			${TEST_CHAP10}

GRAND_TEST_FLAGS = SCHEME="${SCHEME}" YOU_HAVE_TIME="${YOU_HAVE_TIME}"

# # roughly 4 hours.
grand.test :
	${TIME} nice ${MAKE} do.grand.test ${GRAND_TEST_FLAGS}
do.grand.test :
	@for test in ${GRAND_TESTS} 					;	do ( echo Testing $$test ...					;	     ${MAKE} $$test ${GRAND_TEST_FLAGS} ) | tee ${RESULTS}	;	   echo Checking results of $$test ...				;	   ${PERL} perl/check.prl ${RESULTS} $$test			;	   done

	@echo "All tests passed."

grand.test.with.bigloo : o/${HOSTTYPE}/book.bigloo
	${MAKE} grand.test SCHEME=o/$$HOSTTYPE/book.bigloo TIME=time
grand.test.with.sci : o/${HOSTTYPE}/book.sci
	${MAKE} grand.test SCHEME=o/$$HOSTTYPE/book.sci
grand.test.with.scm : o/${HOSTTYPE}/book.scm
	${MAKE} grand.test SCHEME="scm -u -l scm/Init.scm"

# # Test only parts of the grand tour of tests.
TMP_ALL_TESTS =	${TEST_CHAP9}				${TEST_CHAP10}

tmp.grand.test :
	@for test in ${TMP_ALL_TESTS} 					;	do ( echo Testing $$test ...					;	     ${MAKE} $$test ${GRAND_TEST_FLAGS} ) | tee ${RESULTS}	;	   echo Checking results of $$test ...				;	   ${PERL} perl/check.prl ${RESULTS} $$test			;	   done

# ##################################### Chap 1 ##############################

TEST_CHAP1 =	test.chap1

# # chap1.scm contains a naive interpreter written in naive Scheme.
# # 6.40user 1.30system 0:17.72elapsed
test.chap1 : src/chap1.scm
	echo "						(load \"src/chap1.scm\")				(and (test-scheme1 \"src/scheme.tst\")			     (test-scheme1 \"src/chap1.tst\") )"		| ${SCHEME}

# ##################################### Chap 2 ##############################

TEST_CHAP2 =	test.chap2a			test.chap2b			test.chap2c			test.chap2e			test.chap2f			test.chap2g			test.chap2h

# # chap2a.scm contains a little Lisp2 interpreter (eval e env fenv).
# # chap2d.scm displays simple cyclic lists in a finite way.
test.chap2a : src/chap2a.scm
	echo "						(load \"src/chap2a.scm\")				(and (test-chap2a \"src/chap2a.tst\")			     (load \"src/chap2d.scm\")				     'done )"						| ${SCHEME}

# # chap2b.scm adds flet and function to the previous interpreter
src/chap2b.scm : src/chap2a.scm
test.chap2b :  src/chap2b.scm
	echo "						(load \"src/chap2a.scm\")				(load \"src/chap2b.scm\")				(test-scheme2a \"src/chap2b.tst\")"			| ${SCHEME}

# # chap2c.scm adds dynamic variables (eval e env fenv denv)
src/chap2c.scm : src/chap2b.scm
test.chap2c :  src/chap2c.scm
	echo "						(load \"src/chap2a.scm\")				(load \"src/chap2b.scm\")				(load \"src/chap2c.scm\")				(test-scheme2c \"src/chap2c.tst\")"			| ${SCHEME}

# # chap2e.scm adds dynamic variables a la Common Lisp
src/chap2e.scm : src/chap2c.scm
test.chap2e : src/chap2e.scm
	echo "						(load \"src/chap2a.scm\")				(load \"src/chap2b.scm\")				(load \"src/chap2c.scm\")				(load \"src/chap2e.scm\")				(test-scheme2c \"src/chap2e.tst\")"			| ${SCHEME}

# # chap2f.scm adds dynamic variables without special forms
test.chap2f : src/chap2f.scm
	echo "						(load \"src/chap2f.scm\")				(test-scheme2f \"src/chap2f.tst\")"			| ${SCHEME}

# # chap2g.scm adds the let, letrec special forms to chap1.scm (scheme)
src/chap2g.scm : src/chap1.scm
test.chap2g : src/chap2g.scm
	echo "						(load \"src/chap1.scm\")				(load \"src/chap2g.scm\")				(and (test-scheme1 \"src/scheme.tst\")			     (test-scheme1 \"src/chap2g.tst\") )"		| ${SCHEME}

# # chap2h.scm allows extensions such as (1 e) or ((f1 f2) e)
src/chap2h.scm : src/chap1.scm
test.chap2h : src/chap2h.scm
	echo "						(load \"src/chap1.scm\")				(load \"src/chap2h.scm\")				(and (test-scheme1 \"src/scheme.tst\")			     (test-scheme1 \"src/chap2h.tst\") )"		| ${SCHEME}

# ##################################### Chap 3 ##############################

TEST_CHAP3 =	test.chap3f			test.chap3h

# # chap3{a,b,c,d,e}.scm contain excerpts from chapter3

# # chap3f.scm contains an interpreter in OO style
# # 15.69user 1.94system 0:35.62elapsed
test.chap3f : src/chap3g.scm
	echo "						(load \"src/chap3f.scm\")				(load \"src/chap3g.scm\")				(load \"src/chap3h.scm\")				(test-scheme3f \"src/scheme.tst\")"			| ${SCHEME}

# # chap3g.scm defines additional control features (block, catch)
# # chap3h.scm defines unwind-protect
# # chap3j.scm improves chap3f.scm
src/chap3g.scm : src/chap3f.scm
src/chap3h.scm : src/chap3f.scm
src/chap3j.scm : src/chap3f.scm
test.chap3h : src/chap3g.scm
	echo "						(load \"src/chap3f.scm\")				(load \"src/chap3g.scm\")				(load \"src/chap3h.scm\")				(load \"src/chap3j.scm\")				(and (test-scheme3f \"src/scheme.tst\")			     (test-scheme3f \"src/chap3f.tst\") )"		| ${SCHEME}

# ##################################### Chap 4 ##############################

TEST_CHAP4 =	test.chap4

# # chap4.scm contains excerpts from chapter 4
# # chap4a.scm contains a Scheme interpreter coded with nothing but closures.
# # 72.25user 2.45system 1:49.86elapsed
test.chap4 : src/chap4.scm src/chap4a.scm src/chap4.tst
	echo "						(load \"src/chap4.scm\")				(load \"src/chap4a.scm\")				(define box1 'wait)					(define p1 'wait)					(and 							 (file-test \"src/scheme.tst\")				 (set! evaluate new-evaluate)				 (file-test \"src/chap4a.tst\")				 (suite-test \"src/chap4.tst\" \"?? \" \"== \" #t 	    (lambda (read check err)				      (lambda () 					        (check (eval (expand-syntax (read)))) ) )	    naive-match )					)"							| ${SCHEME}

# ##################################### Chap 5 ##############################
# # Denotational semantics

TEST_CHAP5 = 	test.chap5a				loop.test.chap5b			test.chap5c 				test.chap5d 				test.chap5e 				test.chap5f 				test.chap5g				test.chap5h

bench.chap5 :	bench.chap5a

# # 41.63user 2.28system 1:07.39elapsed
test.chap5a : src/chap5a.scm
	echo "							(load \"src/chap5a.scm\")					(test-denScheme \"src/scheme.tst\")"				| ${SCHEME}

# # See typical times a the end of src/chap5-bench.scm
# # 41.23user 1.75system 0:52.19elapsed
bench.chap5a : src/chap5a.scm
	echo "							(load \"src/chap5a.scm\")					(bench \"src/chap5-bench.scm\")"				| ${SCHEME}

# # Obsolete entry
test.chap5a.scc : o/${HOSTTYPE}/chap5a
o/${HOSTTYPE}/chap5a : src/chap5a.scm
	${MAKE} ${MAKEFLAGS} mkdir
	echo "							(module chap5a (main start)(with s2cfun tester meroon))		(include \"s2c+meroonV2.scm\")					(define (start args)						  (test-denScheme \"src/scheme.tst\")				  (bench \"src/chap5-bench.scm\") )				(macroexpand-time-eval						 (define-abbreviation (define call . body)			   (if (pair? call)						       \`(define ,(car call) (lambda ,(cdr call) . ,body))	       \`(set! ,call . ,body) ) ) )				(include \"src/chap5a.scm\")"		> o/${HOSTTYPE}/chap5a.sc

	${SCC} -o o/${HOSTTYPE}/chap5a ${SCCFLAGS} o/${HOSTTYPE}/chap5a.sc 		${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap5a

# # Lambda calculus denotation
# # The last tests loop due to applicative order.
loop.test.chap5b :
	-echo skip that test or run it by hand : ${MAKE} test.chap5b
test.chap5b : src/chap5b.scm
	echo "							(load \"src/chap5b.scm\")					(test-L \"src/chap5b.tst\")"					| ${SCHEME}

# # Scheme + dynamic variables denotational interpreter
test.chap5c : src/chap5c.scm
	echo "							(load \"src/chap5c.scm\")					(and (test-denScheme \"src/scheme.tst\")			     (test-denScheme \"src/chap5c.tst\") )"	 		| ${SCHEME}

# # Same as chap5c except that this one tries to precompute meanings.
# # This is slightly faster than chap5a.
test.chap5d : src/chap5d.scm src/chap5-bench.scm
	echo "							(load \"src/chap5d.scm\")					(test-denScheme \"src/scheme.tst\")"				| ${SCHEME}

# # 39.59user 1.92system 0:54.78elapsed
bench.chap5d : src/chap5d.scm src/chap5-bench.scm
	echo "							(load \"src/chap5d.scm\")					(bench \"src/chap5-bench.scm\")"				| ${SCHEME}

# # 						(obsolete)
test.chap5d.scc : o/${HOSTTYPE}/chap5d
o/${HOSTTYPE}/chap5d : src/chap5d.scm
	${MAKE} ${MAKEFLAGS} mkdir
	echo "							(module chap5d (main start)(with s2cfun tester meroon))		(include \"s2c+meroonV2.scm\")					(define (start args)						  (test-denScheme \"src/scheme.tst\")				  (bench \"src/chap5-bench.scm\") )				(include \"src/chap5d.scm\")"		> o/${HOSTTYPE}/chap5d.sc

	${SCC} -o o/${HOSTTYPE}/chap5d ${SCCFLAGS} o/${HOSTTYPE}/chap5d.sc 		${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	o/${HOSTTYPE}/chap5d

# # Modify the denotational interpreter chap5d to specify that
# # the evaluation order is unspecified.
test.chap5e : src/chap5e.scm
	echo "							(load \"src/chap5d.scm\")					(load \"src/chap5e.scm\")					(test-den+Scheme \"src/chap5e.tst\")" 				| ${SCHEME}

# # CPS without any tests.
test.chap5f : src/chap5f.scm
	echo "					(and (load \"src/chap5f.scm\")			     'done )" 					| ${SCHEME}

# # Same as chap5d with an explicit global environment.
# # 42.34user 2.28system 1:14.96elapsed
test.chap5g : src/chap5g.scm
	echo "							(load \"src/chap5g.scm\")					(and (test-denScheme \"src/scheme.tst\")			     (test-denScheme \"src/chap5g.tst\") )"			| ${SCHEME}

# # Unordered evaluation order simulated with random.
test.chap5h : src/chap5h.scm
	echo "							(load \"src/chap5h.scm\")					(load \"src/chap1.scm\")					(test-scheme1 \"src/scheme.tst\")"				| ${SCHEME}

# ##################################### Chap 6 ##############################
# # Chapter on fast interpretation (by means of precompilation)

TEST_CHAP6 = 	test.chap6a				test.chap6b				test.chap6c				test.chap6d				shared.test.chap6dd			test.chap6e				dynext.test.chap6f			test.chap6g				test.chap6h

bench.chap6 :	bench.chap6a			bench.chap6b			bench.chap6c			bench.chap6d			bench.chap6e

test.chap6.bgl :	test.chap6a.bgl

# # Fast interpretation, code is precompiled into (lambda (sr k)..)
# # 10.71user 1.80system 0:26.55elapsed
test.chap6a : src/chap6a.scm
	echo  "							(load \"src/chap6a.scm\")					(test-Scheme6a \"src/scheme.tst\")"				| ${SCHEME}

# # Interpreted bench
# # 5.42user 0.90system 0:08.78elapsed
bench.chap6a : src/chap6a.scm
	echo  "							(load \"src/chap6a.scm\")					(bench6a 1 (call-with-input-file \"src/chap5-bench.scm\" read))"| ${SCHEME}

# # Compiled bench with Bigloo
# # 129.65user 11.95system 3:15.62elapsed 	(compile)
# # 7.63user 0.54system 0:09.60elapsed 	(10*bench)
test.chap6a.bgl : o/${HOSTTYPE}/rtbook.a o/${HOSTTYPE}/bglchap6a
	${TIME} o/${HOSTTYPE}/bglchap6a 10
o/${HOSTTYPE}/bglchap6a : src/chap6a.scm bigloo/compapp.scm
	echo "								(load \"bigloo/compapp.scm\")						(define the-bench (call-with-input-file \"src/chap5-bench.scm\" read))	(compile-bigloo-application 						  \"${BIGLOO}\" \"o/${HOSTTYPE}/\"					  \"bglchap6a\" 							  \`(bench6a (string->number (cadr command-options))			             ',the-bench )						  \"src/chap6a.scm\" )"						| ${SCHEME}

# # Compiled bench with Scheme->C	(obsolete)
test.chap6a.scc : src/chap6a.scm
	echo "								(module chap6a (main start)(with s2cfun tester meroon syntax-rules))	(include \"s2c+meroonV2.scm\")						(macroexpand-time-eval							  (loadq \"${HOME}/s2c/s2cfun.scm\") )					(include \"src/showGC.s2c\")						(define (start args)							  '(test-Scheme6a \"src/scheme.tst\")					  (bench6a (string->number (cadr args))					           (call-with-input-file \"src/chap5-bench.scm\" read) ) )  	(include \"src/chap6a.scm\")"		> o/${HOSTTYPE}/chap6a.sc

	${SCC} -o o/${HOSTTYPE}/chap6a ${SCCFLAGS} o/${HOSTTYPE}/chap6a.sc 		${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap6a -sch 4 10
# # With chap6a.scm 1.1 -sch 4 10
# #7.54user 0.64system 0:08.28elapsed 98%CPU (844text+5508data 4268max)k
# # With chap6a.scm 1.1 -sch 8 10
# #4.18user 0.54system 0:04.79elapsed 98%CPU (832text+4593data 4048max)k
# # With chap6a.scm 1.1 -sch 16 10
# #4.17user 0.65system 0:05.36elapsed 89%CPU (870text+4760data 4176max)k

# # With chap6a.scm 1.2 -sch 4 10 (vectorized global env)
# #6.68user 0.65system 0:08.31elapsed 88%CPU (997text+5595data 4328max)k
# # With chap6a.scm 1.2 -sch 8 10
# #3.36user 0.58system 0:04.01elapsed 98%CPU (842text+4536data 4052max)k
# # With chap6a.scm 1.2 -sch 16 20
# #6.59user 0.91system 0:07.60elapsed 98%CPU (851text+7110data 6424max)k

# # With chap6a.scm 1.3 -sch 4 10 (allocation frame)
# #7.89user 0.54system 0:08.92elapsed 94%CPU (1045text+5856data 4428max)k
# # With chap6a.scm 1.3 -sch 8 10
# #3.48user 0.54system 0:04.13elapsed 97%CPU (849text+4686data 4156max)k
# # With chap6a.scm 1.3 -sch 16 10
# #3.22user 0.70system 0:04.04elapsed 97%CPU (841text+4912data 4284max)k

# # New version chap6a.scm 1.4 -sch 4 10 (inline+g.init)
# # No more GC with an initial heap of 4 megs.
# #2.87user 0.53system 0:04.32elapsed 78%CPU (993text+3906data 3704max)k
# # With chap6a.scm 1.4 -sch 8 10
# #2.84user 0.50system 0:03.42elapsed 97%CPU (822text+4109data 3696max)k

# # New version chap6a.scm 1.5 -sch 4 10 (closed-application+primitive+inline)
# #2.36user 0.50system 0:03.46elapsed 82%CPU (1021text+3033data 2980max)k
# # chap6a -sch 16 100 [1 gc]
# #25.5user 2.94system 0:34.76elapsed 80%CPU (907text+17464data 16076max)k
# # try with optimizations turned on in scc (SCCFLAGS= -Ob -Og -On -Ot)
# #18.55user 2.47system 0:24.77elapsed 84%CPU (1014text+16738data 16284max)k

# # New version with better written code chap6a.scm 1.6 -sch 4 10
# #2.44user 0.53system 0:03.52elapsed 84%CPU (1036text+3068data 2996max)k
# # (globalized listify! function) chap6a.scm 1.7 -sch 4 10
# #2.37user 0.50system 0:03.21elapsed 89%CPU (839text+3101data 2916max)k
# # chap6a 1.7 -sch 16 100 [1 gc]
# #25.66user 2.63system 0:28.87elapsed 97%CPU (895text+17803data 17148max)k

# # Testing the same fast interpreter with Bigloo (intepreted)
test.chap6.bgl :
	echo "								(define primes								  (lambda (n f max)							    ((lambda (filter)							       (begin								         (set! filter (lambda (p)					                        (lambda (n) (= 0 (remainder n p))) ))		         (if (> n max)							             '()							             (if (f n)							                 (primes (+ n 1) f max)					                 (cons n						                       ((lambda (ff)					                          (primes (+ n 1)				                                  (lambda (p) (if (f p) #t (ff p)))	                                  max ) )				                        (filter n) ) ) ) ) ) )				     'wait ) ) )							(define (bench factor)							  (let loop ((factor factor))						    (let ((v (eval '(primes 2 (lambda (x) #f) 50))))			      (if (> factor 1)							          (loop (- factor 1))						          (display v) ) ) ) )						(bench 100)" 	| ${TIME} bigloo -i

# # (bench 10)
# #0.89user 0.22system 0:02.24elapsed 49%CPU (958text+1151data 1612max)k
# # (bench 100)
# #4.48user 0.41system 0:06.38elapsed 76%CPU (1392text+2377data 2704max)k

# # Compare on the fast interpreter the speed of Bigloo wrt Scheme->C.
test.chap6 :
	echo "								(define primes								  (lambda (n f max)							    ((lambda (filter)							       (begin								         (set! filter (lambda (p)					                        (lambda (n) (= 0 (remainder n p))) ))		         (if (> n max)							             '()							             (if (f n)							                 (primes (+ n 1) f max)					                 (cons n						                       ((lambda (ff)					                          (primes (+ n 1)				                                  (lambda (p) (if (f p) #t (ff p)))	                                  max ) )				                        (filter n) ) ) ) ) ) )				     'wait ) ) )							(define (bench factor)							  (let loop ((factor factor))						    (let ((v (eval '(primes 2 (lambda (x) #f) 50))))			      (if (> factor 1)							          (loop (- factor 1))						          (display v) ) ) ) )						(bench 100)" 	| ${TIME} sci

# # (bench 10)
# #0.75user 0.21system 0:03.79elapsed 25%CPU (1290text+716data 1328max)k
# # (bench 100)
# #6.86user 0.69system 0:08.87elapsed 85%CPU (1429text+3266data 3840max)k

# # Compare also with CAML light
test.chap6.ml :
	echo "								let rec primes n f max =						 let filter p n = ( 0 = n mod p)					 in if ( n > max) then []						    else if (f n) then primes (n+1) f max				         else n :: let ff = (filter n)					                   in primes (n+1) 					                             (function p -> if (f p) then true 		                                            else (ff p)) 		                             max;;					let bench factor =							  let rec loop factor =							    let v = primes 2 (fun x -> false) 50 				    in if (factor > 1) then loop (factor-1)				       else v								  in loop factor;;							bench 100;;"		| ${TIME} camllight

# # bench 10;;
# #0.51user 0.21system 0:01.27elapsed 56%CPU (96text+542data 448max)k
# # bench 100;;
# #1.43user 0.24system 0:02.21elapsed 75%CPU (101text+693data 456max)k

# # patch to chap6a.scm to define new global variables on the fly:
# # 11.06user 1.86system 0:31.25elapsed
test.chap6b : src/chap6a.scm src/chap6b.scm
	echo  "							(load \"src/chap6a.scm\")					(load \"src/chap6b.scm\")					(and (test-Scheme6b \"src/chap6b.tst\")				     (test-Scheme6b \"src/scheme.tst\") )"			| ${SCHEME}

# # Interpreted bench
# # 5.65user 0.89system 0:11.17elapsed
bench.chap6b : src/chap6a.scm src/chap6b.scm
	echo  "							(load \"src/chap6a.scm\")					(load \"src/chap6b.scm\")					(bench6a 1 (call-with-input-file \"src/chap5-bench.scm\" read))	"								| ${SCHEME}

# # Environment is now held in a global variable *env*.
# # Programs are precompiled into (lambda (k) ...)
# # 11.97user 2.01system 0:34.30elapsed
test.chap6c : src/chap6c.scm
	echo  "							(load \"src/chap6a.scm\")					(load \"src/chap6c.scm\")					(test-Scheme6c \"src/scheme.tst\")"				| ${SCHEME}

# # Interpreted bench
bench.chap6c : src/chap6c.scm
	echo  "							(load \"src/chap6a.scm\")					(load \"src/chap6c.scm\")					(bench6c 1 (call-with-input-file \"src/chap5-bench.scm\" read))	"								| ${SCHEME}

# # Compile it with scc.			(obsolete)
test.chap6c.scc : src/chap6c.scm
	${MAKE} ${MAKEFLAGS} mkdir
	echo "								(module chap6c (main start)(with s2cfun tester meroon syntax-rules))	(include \"s2c+meroonV2.scm\")						(macroexpand-time-eval							  (loadq \"${HOME}/s2c/s2cfun.scm\") )					(include \"src/showGC.s2c\")						(define (start args)							  '(test-Scheme6c \"src/scheme.tst\")					  (bench6c (string->number (cadr args))					           (call-with-input-file \"src/chap5-bench.scm\" read) ) )  	(include \"src/chap6a.scm\")						(include \"src/chap6c.scm\")"		> o/${HOSTTYPE}/chap6c.sc

	${SCC} -o o/${HOSTTYPE}/chap6c ${SCCFLAGS} o/${HOSTTYPE}/chap6c.sc 		${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap6c -sch 4 10
# # chap6c.scm 1.2 -sch 4 10 (same as chap6a.scm: No gain !)
# #2.40user 0.48system 0:03.02elapsed 95%CPU (843text+3152data 2984max)k
# # chap6c -sch 16 100 [1 gc]
# #25.51user 2.58system 0:28.99elapsed 96%CPU (1068text+17836data 17268max)k

# # Make continuation implicit.
# # The program is precompiled into (lambda ()...)
# # 11.09user 1.90system 0:27.29elapsed
test.chap6d : src/chap6d.scm
	echo  "							(load \"src/chap6d.scm\")					(test-Scheme6d \"src/scheme.tst\")"				| ${SCHEME}

# # Interpreted bench
# # 5.35user 0.81system 0:10.35elapsed
bench.chap6d : src/chap6d.scm
	echo  "							(load \"src/chap6d.scm\")					(bench6d 1 (call-with-input-file \"src/chap5-bench.scm\" read))"  | ${SCHEME}

# # Variant with pre-allocated frames (work for Lisp not for Scheme)
# # An error is expected on one of the lattest tests on call/cc. This
# # test is preceded by the string "The following test forces a
# # continuation to return multiply."
shared.test.chap6dd : test.chap6dd
test.chap6dd : src/chap6d.scm src/chap6dd.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap6dd.scm\")					(and (test-Scheme6d \"src/chap6dd.tst\")			     (test-Scheme6d \"src/scheme.tst\") )"  			| ${SCHEME}

# # Compile with scc				(obsolete)
test.chap6d.scc : src/chap6d.scm
	${MAKE} ${MAKEFLAGS} mkdir
	echo "								(module chap6d (main start)(with s2cfun tester meroon syntax-rules))	(include \"s2c+meroonV2.scm\")						(macroexpand-time-eval							  (loadq \"${HOME}/s2c/s2cfun.scm\") )					(include \"src/showGC.s2c\")						(define (start args)							  '(test-Scheme \"src/scheme.tst\")					  (bench (string->number (cadr args))					         (call-with-input-file \"src/chap5-bench.scm\" read) ) )  	(include \"src/chap6d.scm\")"		> o/${HOSTTYPE}/chap6d.sc

	${SCC} -o o/${HOSTTYPE}/chap6d ${SCCFLAGS} 		o/${HOSTTYPE}/chap6d.sc ${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap6d -sch 4 10
# # chap6d.scm 1.1 -sch 4 10 (similar to Bigloo)
# #0.86user 0.15system 0:01.16elapsed 87%CPU (786text+646data 908max)k
# # chap6d.scm 1.1 -sch 16 100 [No GC] (slower than Bigloo)
# #7.50user 0.42system 0:08.02elapsed 98%CPU (876text+2753data 2808max)k
# # chap6d.scm 1.4 -sch 4 10 (explicit closures)
# #0.96user 0.10system 0:01.21elapsed 87%CPU (885text+705data 1044max)k
# # chap6d.scm 1.4 -sch 16 100
# #7.89user 0.45system 0:08.45elapsed 98%CPU (1019text+3152data 3288max)k
# # chap6d.scm 1.4 -sch 4 10 (explicit closures) -Ot -Ob -Og
# #0.74user 0.17system 0:01.97elapsed 46%CPU (1107text+653data 1124max)k
# # chap6d.scm 1.4 -sch 16 100 -Ot -Ob -Og  (still slower than bigloo)
# #6.21user 0.46system 0:06.78elapsed 98%CPU (998text+3100data 3256max)k
# # chap6d.scm 1.5 -sch 4 10 (simplified bench/bigloo)
# #0.88user 0.11system 0:01.08elapsed 91%CPU (874text+683data 1016max)k
# # chap6d.scm 1.5 -sch 16 100
# #7.14user 0.42system 0:07.64elapsed 98%CPU (977text+2861data 2984max)k

# # a small byte-tree-code compiler. (Not used in the book)
# #
test.chap6e : src/chap6e.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap6e.scm\")					(test-Scheme6e \"src/scheme.tst\")"				| ${SCHEME}

bench.chap6e : src/chap6e.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap6e.scm\")					(bench6e 1 (call-with-input-file \"src/chap5-bench.scm\" read))	"								| ${SCHEME}

# # Same compiled with scc.			(obsolete)
test.chap6e.scc : src/chap6e.scm
	${MAKE} ${MAKEFLAGS} mkdir
	echo "								(module chap6e (main start)(with s2cfun tester meroon syntax-rules))	(include \"s2c+meroonV2.scm\")						(macroexpand-time-eval							  (loadq \"${HOME}/s2c/s2cfun.scm\") )					(include \"src/showGC.s2c\")						(define (start args)							  '(test-Scheme \"src/scheme.tst\")					  (bench (string->number (cadr args))					         (call-with-input-file \"src/chap5-bench.scm\" read) ) )  	(include \"src/chap6e.scm\")"		> o/${HOSTTYPE}/chap6e.sc

	${SCC} -o o/${HOSTTYPE}/chap6e ${SCCFLAGS} -Ob -Og -Ot 		o/${HOSTTYPE}/chap6e.sc ${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap6e -sch 4 10
# # chap6e 1.2 -sch 4 10  (slower than chap6d)
# #1.32user 0.12system 0:01.72elapsed 83%CPU (991text+690data 1028max)k
# # -sch 16 100
# #11.64user 0.42system 0:12.36elapsed 97%CPU (1079text+2872data 3004max)k
# # chap6e 1.2 -sch 4 10 (with -Ob -Og -Ot) Very dependent of these options
# #0.72user 0.13system 0:01.12elapsed 75%CPU (870text+643data 996max)k
# # chap6e 1.2 -sch 16 100 (with -Ob -Og -Ot) (Closer to Bigloo now !)
# #5.73user 0.48system 0:06.51elapsed 95%CPU (988text+2813data 2972max)k
# # chap6e is very dependent on tests on types in byte-eval
# # but faster than Scheme->C.

# ########### Skip chap6f which was superseded by chap10.
# # Small compiler towards C (not in the book but still working)
# # This compiler uses a different pattern of C generation and a variant
# # for environment management. That's why I leave it here. It is
# # grafted to the precompiler similarly to the bytecode compiler.
# # ATTENTION, this is a very long test:
# # 751.89user 555.90system 42:25.34elapsed
long.dynext.test.chap6f :
	if ${YOU_HAVE_TIME} ; then ${MAKE} dynext.test.chap6f ; else : ; fi
dynext.test.chap6f : test.chap6f
test.chap6f : o/${HOSTTYPE}/rt.o src/chap6f.scm
	echo  "							(load \"src/chap6f.scm\")					(test-Scheme \"src/scheme.tst\")" 				| ${SCHEME}

# # start an interpreter to interactively compile towards C.
# # The (scheme) toplevel reads an expression and shows the generated C.
# # This test fails on continuation used out of their dynamic extent (no
# # full continuation a la Scheme).
start.chap6f : o/${HOSTTYPE}/rt.o src/chap6f.scm
	@( echo  "						(load \"src/chap6f.scm\")					(scheme)" ; tee ) | ${SCHEME}

# # Compile the compiler.				(obsolete)
test.chap6f.scc : o/${HOSTTYPE}/rt.o src/chap6f.scm
	${MAKE} ${MAKEFLAGS} mkdir
	echo "								(module chap6f (main start)(with s2cfun tester meroon syntax-rules))	(include \"s2c+meroonV2.scm\")						(macroexpand-time-eval							  (loadq \"${HOME}/s2c/s2cfun.scm\") )					(include \"src/showGC.s2c\")						(define (start args)                                                      (if (pair? (cdr args))(test-scheme (cadr args))(scheme)) )            (include \"src/chap6f.scm\")"		> o/${HOSTTYPE}/chap6f.sc

	${SCC} -o o/${HOSTTYPE}/chap6f ${SCCFLAGS} -Ob -Og -Ot 		o/${HOSTTYPE}/chap6f.sc ${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap6f -sch 8 src/scheme.tst

# # A little bench to appreciate the compiler speed.	(obsolete)
bench.chap6f : o/${HOSTTYPE}/chap6f-bench
	${TIME} o/${HOSTTYPE}/chap6f-bench

CaFLAGS	=	-I../../src/c ${CFLAGS}

o/${HOSTTYPE}/chap6f-bench.c : src/chap6f.scm src/chap5-bench.scm
	echo  "							(loadq \"src/chap6f.scm\")					(compile-file \"src/chap5-bench.scm\" \"o/${HOSTTYPE}/tt.c\")	"	| ${SCHEME} -sch 8

	-indent o/${HOSTTYPE}/tt.c

# # The runtime in C for that compiler. Generates a lot of warnings...
# # superseded by the new library src/c/scheme*.[ch] (but this one
# # contains a GC).
o/${HOSTTYPE}/rt.o : src/c/rt.c src/c/rt.h
	cd o/${HOSTTYPE} ; ${CC} -c ${CaFLAGS} ../../src/c/rt.c
o/${HOSTTYPE}/chap6f-bench : o/${HOSTTYPE}/chap6f-bench.c
o/${HOSTTYPE}/chap6f-bench : src/c/rt.h o/${HOSTTYPE}/rt.o
	cd o/${HOSTTYPE} ; ${CC} -o tt ${CaFLAGS} chap6f-bench.c rt.o

# # Compile the compiler				(obsolete)
test.chap6f.scc : src/chap6f.scm
	echo "								(module chap6f (main start)(with s2cfun tester meroon syntax-rules))	(include \"s2c+meroonV2.scm\")						(macroexpand-time-eval							  (loadq \"${HOME}/s2c/s2cfun.scm\") )					(include \"src/showGC.s2c\")						(define (start args)							  '(test-Scheme \"src/scheme.tst\")					  (bench (string->number (cadr args))					         (call-with-input-file \"src/chap5-bench.scm\" read) ) )  	(include \"src/chap6f.scm\")"		> o/${HOSTTYPE}/chap6f.sc

	${SCC} -o o/${HOSTTYPE}/chap6f ${SCCFLAGS}  		o/${HOSTTYPE}/chap6f.sc ${HOME}/s2c/o/${HOSTTYPE}/libqnc.a

	${TIME} o/${HOSTTYPE}/chap6f -sch 4 10
# ########### end of chap6f which was superseded by chap10.	(obsolete)

# # Handling the define special form.
test.chap6g : src/chap6a.scm src/chap6b.scm src/chap6g.scm
	echo  "							(load \"src/chap6a.scm\")					(load \"src/chap6b.scm\")					(load \"src/chap6g.scm\")					(and (test-Scheme6b \"src/chap6g.tst\")				     (test-Scheme6b \"src/scheme.tst\") )"			| ${SCHEME}

# # exercice on a specialized invocation protocol for thunks
test.chap6h : src/chap6d.scm src/chap6h.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap6h.scm\")					(test-Scheme6d \"src/scheme.tst\")"  				| ${SCHEME}

# ##################################### Chap 7 ##############################
# # Bytecode compilation

TEST_CHAP7 =		test.chap7a				test.chap7b 				test.chap7c				test.chap7d 				test.chap7e 				test.chap7g 				test.chap7h				shallow.test.chap7i

# # Linearize the intermediate language to make register *val* appear.
# # 13.48user 1.84system 0:31.70elapsed
test.chap7a : src/chap6d.scm src/chap7a.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7a.scm\")					(test-Scheme7a \"src/scheme.tst\")"  		| ${SCHEME}

# # make stack appear (as well as other registers)
# # 13.91user 1.81system 0:33.46elapsed
test.chap7b : src/chap6d.scm src/chap7b.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7b.scm\")					(test-Scheme7b \"src/scheme.tst\")"  		| ${SCHEME}

# # represents instructions by list of closures. Make register PC appear.
# # 18.09user 1.95system 0:42.60elapsed
test.chap7c : src/chap6d.scm src/chap7c.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7c.scm\")					(test-Scheme7c \"src/scheme.tst\")"  		| ${SCHEME}

# # the complete bytecode compiler itself.
# # The instruction set is defined in chap7f but is directly
# # handled by chap7d.
# # 64.28user 2.92system 1:39.47elapsed
test.chap7d : src/chap6d.scm src/chap7d.scm src/chap7f.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7d.scm\")					(test-Scheme7d \"src/scheme.tst\")"  		| ${SCHEME}

# # added bind-exit, dynamic variables and error handling (first version
# # with dynenv register) in the bytecode compiler.
# # 106.45user 4.26system 2:48.65elapsed
test.chap7e : src/chap7d.scm src/chap7e.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7d.scm\")					(load \"src/chap7e.scm\")					(and (test-Scheme7e \"src/scheme.tst\")				     (test-Scheme7e \"src/chap7d.tst\")				     (test-Scheme7e \"src/chap5c.tst\") )"  		| ${SCHEME}

# # chap7f.scm contains the definition of the instructions of the machine

# # separate compilation stuff, link compiled files, build stand-alone
# # with the bytecode compiler.
# # 219.27user 13.58system 8:47.39elapsed
test.chap7g : src/chap7h.scm src/chap7g.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7d.scm\")					(load \"src/chap7h.scm\")					(load \"src/chap7g.scm\")					(and (test-Scheme7g \"src/scheme.tst\")				     (test-Scheme7g \"src/chap7d.tst\")				     (test-Scheme7g \"src/chap5c.tst\") )			(compile-file \"tmp.si/foo\")					(run-application 100 \"tmp.si/foo.so\")				(compile-file \"tmp.si/fact\")					(compile-file \"tmp.si/fib\")					(compile-file \"tmp.si/after\")					(build-application \"tmp.si/a.out\" 				   \"tmp.si/fact\" \"tmp.si/fib\" 				   \"tmp.si/foo\" \"tmp.si/after\" )				(run-application 400 \"tmp.si/a.out\")				(build-application-renaming-variables 				     \"tmp.si/na.out\" \"tmp.si/a.out\" 			     '((fib fact) (fact fib)) )					(run-application 400 \"tmp.si/na.out\")				(assoc 'long-goto (disassemble *code*))"  		| ${SCHEME}

# # implementation variant for dynamic variables, error handlers
# # with labels in the stack (without dynenv register).
# # 106.77user 4.34system 2:49.31elapsed
test.chap7h : src/chap7d.scm src/chap7h.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7d.scm\")					(load \"src/chap7h.scm\")					(and (test-Scheme7h \"src/scheme.tst\")				     (test-Scheme7h \"src/chap7d.tst\")				     (test-Scheme7h \"src/chap5c.tst\") )"  		| ${SCHEME}

# # shallow binding for dynamic variables
# # It will fail on the last test of src/chap7d.tst
shallow.test.chap7i : test.chap7i
test.chap7i : src/chap7h.scm
	echo  "							(load \"src/chap6d.scm\")					(load \"src/chap7d.scm\")					(load \"src/chap7h.scm\")					(load \"src/chap7i.scm\")					(and (test-Scheme7h \"src/scheme.tst\")				     (test-Scheme7h \"src/chap5c.tst\")				     (test-Scheme7h \"src/chap7d.tst\") )"  		| ${SCHEME}

# ##################################### Chap 8 ##############################
# # Chapter on evaluation and reflection

TEST_CHAP8 =	test.chap8a				test.chap8b				test.chap8c				test.chap8d				evalf.test.chap8e			evalf.test.chap8f			evalf.test.chap8g			test.chap8h				test.chap8i				big.test.chap8j				test.reflisp

# # add eval/ce (as a special form) to the naive interpreter of chapter 1.
# # 7.33user 1.62system 0:20.39elapsed
test.chap8a : src/chap8a.scm src/chap1.scm
	echo "					(load \"src/chap1.scm\")			(load \"src/chap8a.scm\")			(and (test-scheme1 \"src/scheme.tst\")		     (test-program \"src/chap8.tst\") 		     (set! set-global-value! dynamic-set-global-value!)		     (test-scheme1 \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # Add eval/ce (as a special form) to the predenotational interpreter
# # (with closures everyhere) seen in chapter 4.
# # 72.39user 2.33system 1:34.67elapsed
test.chap8b : src/chap8b.scm src/chap4a.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap4a.scm\")			(load \"src/chap8b.scm\")			(and (file-test \"src/scheme.tst\")		     (file-test \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # Add eval/ce (as a special form) to the threaded interpreter of chapter 6.
# # 12.58user 2.06system 0:34.32elapsed
test.chap8c : src/chap8c.scm src/chap6d.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap8c.scm\")			(and (test-scheme6d \"src/scheme.tst\")	     (test-scheme6d \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # Add eval/ce (as a special form) to the bytecode compiler
# # 157.23user 14.52system 5:20.46elapsed
test.chap8d : src/chap8c.scm src/chap8d.scm src/chap6d.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8d.scm\")			(and (test-scheme7g \"src/scheme.tst\")		     (test-Scheme7g \"src/chap5c.tst\")		     (test-Scheme7g \"src/chap7d.tst\")		     (test-scheme7g \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # add eval/at (a function) as a function to the naive interpreter
# # It fails on a test preceded by "eval as a function will fail..."
# # 7.39user 1.47system 0:21.48elapsed
evalf.test.chap8e : src/chap8e.scm src/chap1.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap1.scm\")			(load \"src/chap8e.scm\")			(and (test-scheme1 \"src/scheme.tst\")		     (test-scheme1 \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # add eval/at (a function) to the bytecode compiler.
# # It fails on a test preceded by "eval as a function will fail..."
# # 156.77user 14.10system 5:03.18elapsed
evalf.test.chap8f : src/chap8f.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8f.scm\")			(and (test-scheme7g \"src/scheme.tst\")		     (test-Scheme7g \"src/chap5c.tst\")		     (test-Scheme7g \"src/chap7d.tst\")		     (test-scheme7g \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # represent interpreted functions as functions in the naive interpreter.
# # It fails on a test preceded by "eval as a function will fail..."
# # 8.28user 1.43system 0:20.69elapsed
evalf.test.chap8g : src/chap8g.scm src/chap1.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap1.scm\")			(load \"src/chap8g.scm\")			(and (test-scheme1 \"src/scheme.tst\")		     (test-scheme1 \"src/chap8a.tst\")		     )"						| ${SCHEME}

# # Add the export special form and a binary function eval/b,
# # also add procedure->body and procedure->environment.
# # 173.64user 15.58system 5:33.69elapsed
test.chap8h : src/chap8h.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8h.scm\")			(and (test-scheme7g \"src/scheme.tst\")		     (test-Scheme7g \"src/chap5c.tst\")		     (test-Scheme7g \"src/chap7d.tst\")		     (test-scheme7g \"src/chap8h.tst\")		     )"						| ${SCHEME}

# # add the import special form
# # 180.38user 16.38system 5:48.37elapsed
test.chap8i : src/chap8i.scm
	echo "					(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8h.scm\")			(load \"src/chap8i.scm\")			(and (test-scheme7g \"src/scheme.tst\")		     (test-Scheme7g \"src/chap5c.tst\")		     (test-Scheme7g \"src/chap7d.tst\")		     (test-scheme7g \"src/chap8h.tst\")		     (test-scheme7g \"src/chap8i.tst\")		     )"						| ${SCHEME}

# # a little reflective interpreter.
# # Pay attention, this is very long and needs much much space...
# # 674.78user 111.28system 33:32.47elapsed
long.test.chap8j :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap8j ; else : ; fi
big.test.chap8j : test.chap8j
test.chap8j : src/chap8h.scm si/reflisp.scm
	( echo "				(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8h.scm\")			(load \"src/chap8j.scm\")			(call-with-input-file \"si/reflisp.scm\"	  (lambda (in) 					    (let ((e (read in)))			      (call-with-output-file \"tmp.si/tmp.scm\"	        (lambda (out)					   (write \`((lambda (reflisp-code) ,e)	                     ',e ) out )			   (newline out) ) ) ) ) )		(compile-file \"tmp.si/tmp\")			(build-application \"tmp.si/a.out\" \"tmp.si/tmp\")		(display \`(byte-size is ,(vector-length *code*)))(newline)	(and (run-application 400 \"tmp.si/a.out\") 'done)"		;	  cat src/chap8j.tst )			| ${SCHEME}

tmp.test.chap8j :
	( echo "				(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8h.scm\")			(load \"src/chap8j.scm\")			(and (run-application 400 \"tmp.si/a.out\") 'done)"	;	  cat src/chap8j.tst )				| ${SCHEME}

# # a direct test of the reflective interpreter
# # 29.32user 2.25system 0:37.23elapsed
test.reflisp : si/reflisp.scm src/chap8k.scm
	( echo "				(load \"src/chap8a.scm\")			(load \"src/chap6d.scm\")			(load \"src/chap7d.scm\")			(load \"src/chap7h.scm\")			(load \"src/chap7g.scm\")			(load \"src/chap8h.scm\")			(load \"src/chap8j.scm\")			(load \"src/chap8k.scm\")			(begin (display \`(cons-size is ,(count-pairs reflisp-code)))(newline))	(and (reflisp) 'done)" ; cat src/chap8j.tst )		| ${SCHEME}

# ##################################### Chap 9 #############################
# # Chapter on macros

TEST_CHAP9 =	test.chap9c

# # A macro system (hygien if I want it, where I want it).
# # 40.60user 3.69system 2:02.59elapsed
test.chap9c : src/chap9c.scm
	echo "					(load \"src/chap9c.scm\")			(load \"src/chap9d.scm\")			(load \"src/chap9e.scm\")			(and (test-scheme9d \"src/scheme.tst\")	     (test-scheme9d \"src/chap9c.tst\") )"	| ${SCHEME}

# ##################################### Chap 10 #############################
# # Chapter on compilation -> C

TEST_CHAP10 =	test.chap10a				test.chap10c				dynext.test.chap10e			test.chap10k				dynext.test.chap10je			test.chap10jk

# # chap10a.scm: objectification
# # chap10b.scm: small interpreter for objectified code
# # 16.74user 1.91system 0:38.87elapsed
test.chap10a : src/chap10a.scm src/chap10b.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10b.scm\")			(and (test-scheme10b \"src/scheme.tst\"))"	| ${SCHEME}

# # chap10c.scm: extract and globalize quotations
# # chap10d.scm: interpret the objectified code
# # 29.68user 2.30system 1:33.23elapsed
test.chap10c : src/chap10a.scm src/chap10b.scm
test.chap10c : src/chap10c.scm src/chap10d.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10b.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10d.scm\")			(and (test-scheme10b \"src/scheme.tst\"))"	| ${SCHEME}

all-o = 	o/${HOSTTYPE}/scheme.o 		o/${HOSTTYPE}/schemelib.o 		o/${HOSTTYPE}/schemeklib.o

o/${HOSTTYPE}/scheme.o : src/c/scheme.h src/c/scheme.c
	cd o/${HOSTTYPE} ; ${CC} ${CFLAGS} -c ../../src/c/scheme.c
o/${HOSTTYPE}/schemelib.o : src/c/scheme.h src/c/schemelib.c
	cd o/${HOSTTYPE} ; ${CC} ${CFLAGS} -c ../../src/c/schemelib.c
o/${HOSTTYPE}/schemeklib.o : src/c/scheme.h src/c/schemeklib.c
	cd o/${HOSTTYPE} ; ${CC} ${CFLAGS} -c ../../src/c/schemeklib.c

# # chap10e.scm: C generation
# # chap10g.scm: lifting, quotation extraction.
# # chap10h.scm: predefined environment
# # chap10f.scm: tests on test-suites
# # This test is very long... but it fails on continuations that are used
# # out of their dynamic extent or multiply.
# # 593.30user 492.04system 25:24.63elapsed
long.dynext.test.chap10e :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10e ; else : ; fi
dynext.test.chap10e : test.chap10e
test.chap10e : src/chap10a.scm src/chap10c.scm
test.chap10e : src/chap10g.scm src/chap10e.scm
test.chap10e : src/chap10h.scm src/chap10f.scm
test.chap10e : o/${HOSTTYPE}/scheme.o
test.chap10e : o/${HOSTTYPE}/schemelib.o
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(and (test-scheme10e \"src/chap10e.tst\")	     (test-scheme10e \"src/scheme.tst\") )"	| ${SCHEME}

# # chap10m.scm contains the letify function that recursively copies an AST
# # into a pure tree, trying to insert let forms.
# # This test is very long... but it fails on continuations that are used
# # out of their dynamic extent or multiply.
# # 598.56user 490.32system 22:40.07elapsed
long.dynext.test.chap10n :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10n ; else : ; fi
dynext.test.chap10n : test.chap10n
test.chap10n : src/chap10m.scm src/chap10n.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(load \"src/chap10m.scm\")			(load \"src/chap10n.scm\")			(and (test-scheme10e \"src/chap10e.tst\")	     (test-scheme10e \"src/scheme.tst\") )"	| ${SCHEME}

# # Generate the C code corresponding to the running example of chapter 10.
# # The C code will be left in o/chap10ex.c
chap10e.example : src/c/chap10ex.c
src/c/chap10ex.c : src/chap10ex.scm src/chap10e.scm
	echo "						(load \"src/chap10a.scm\")				(load \"src/chap10c.scm\")				(load \"src/chap10g.scm\")				(load \"src/chap10e.scm\")				(load \"src/chap10h.scm\")				(load \"src/chap10f.scm\")				(set! *cc+cflags* \"${CC} ${CFLAGS}\")			(call-with-input-file \"src/chap10ex.scm\"		   (lambda (in) (test-expression (read in))) )"		| ${SCHEME}

	size o/${HOSTTYPE}/chap10e
	emacs -batch -l el/c-indent.el
	mv o/chap10e.c src/c/chap10ex.c

# # This is the best I can to show the expanded version of the file. It needs
# # to be hacked a little by hand before being inserted in the book.
src/c/chap10ex.E : perl/indent-E.prl perl/preindent.prl
src/c/chap10ex.E : src/c/chap10ex.c src/c/scheme.h
	perl/preindent.prl < src/c/scheme.h > /tmp/scheme.h
	cp src/c/chap10ex.c /tmp/chap10ex.c
	cd /tmp ; ${CC} ${CFLAGS} -E chap10ex.c -o chap10ex.E
	perl/indent-E.prl < /tmp/chap10ex.E > src/c/chap10ex.E
	rm /tmp/scheme.h /tmp/chap10ex.[Ec]
	indent src/c/chap10ex.E

# # Compile this compiler with Bigloo
# # I patched a little the o/${HOSTTYPE}/LiSPbookc.bgl file because of
# # a bug on write on strings containing \". To be solved.
# # 225.49user 18.02system 4:53.16elapsed
o/${HOSTTYPE}/LiSPbookc :
	H_DIR=`pwd`/src/c/ ; export H_DIR 			;	A_FILE=`pwd`/o/${HOSTTYPE}/rtbook.a ; export A_FILE	;	echo "							(load \"bigloo/compapp.scm\")					'(set! *verbose* #t)						(compile-bigloo-application 					  \"${BIGLOO}\" \"o/${HOSTTYPE}/\"				  \"LiSPbookc\" 						  '(begin (set! *h-dir* \"$$H_DIR\")					  (set! *rtbook-library* \"$$A_FILE\")			          (compiler-entry-point command-options) )		  \"src/chap10a.scm\" 						  \"src/chap10c.scm\" 						  \"src/chap10g.scm\" 						  \"src/chap10e.scm\" 						  \"src/chap10h.scm\" 						  \"src/chap10f.scm\" 						)"								| ${SCHEME}

# # The following entries do not work since the rtbook.a library is not
# # sufficient: IO operations are missing.
# # Compile the compiler with itself (stage 2)
o/${HOSTTYPE}/LiSPbookc2 : o/${HOSTTYPE}/LiSPbookc
	${TIME} o/${HOSTTYPE}/LiSPbookc o/${HOSTTYPE}/LiSPbookc.bgl -v 		-o o/${HOSTTYPE}/LiSPbookc2 -C o/${HOSTTYPE}/LiSPbookc2.c

# # Recompile the compiler with itself (stage 3)
o/${HOSTTYPE}/LiSPbookc3 : o/${HOSTTYPE}/LiSPbookc2
	${TIME} o/${HOSTTYPE}/LiSPbookc2 o/${HOSTTYPE}/LiSPbookc.bgl -v 		-o o/${HOSTTYPE}/LiSPbookc3 -C o/${HOSTTYPE}/LiSPbookc3.c

LiSPbookc.compare : o/${HOSTTYPE}/LiSPbookc3
	ls -l o/${HOSTTYPE}/LiSPbookc*[23].c
	diff o/${HOSTTYPE}/LiSPbookc*[23].c | wc
	size o/${HOSTTYPE}/LiSPbookc*[23]

# # chap10i.scm : *Untested* variants for function invokation since
# # it requires a change in SCM_invoke (in scheme.c).
# # This test is very long... but it fails on continuations that are used
# # out of their dynamic extent or multiply.
long.dynext.test.chap10i :
	if ${YOU_HAVE_TIME} ; then ${MAKE} dynext.test.chap10i ; else : ; fi
dynext.test.chap10i : test.chap10i
test.chap10i : src/chap10a.scm src/chap10c.scm
test.chap10i : src/chap10g.scm src/chap10e.scm
test.chap10i : src/chap10h.scm src/chap10f.scm src/chap10i.scm
test.chap10i : o/${HOSTTYPE}/scheme.o
test.chap10i : o/${HOSTTYPE}/schemelib.o
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(load \"src/chap10i.scm\")			(and (test-scheme10e \"src/scheme.tst\")	     (test-scheme10e \"src/chap10e.tst\") )"	| ${SCHEME}

# # as for various interpreters, try our usual bench.
# # Compile it and run it.
chap10e.bench : o/${HOSTTYPE}/scheme.o
chap10e.bench : o/${HOSTTYPE}/schemelib.o
chap10e.bench : src/chap5-bench.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(call-with-input-file \"src/chap5-bench.scm\" 	  (lambda (in) (test-expression (read in))) )"	| ${SCHEME}

	${TIME} o/${HOSTTYPE}/chap10e
# #0.01user 0.01system 0:00.07elapsed 28%CPU (16avgtext+36avgdata 44maxresident)k
# #0inputs+1outputs (0major+8minor)pagefaults 0swaps

# # Start a compiler.
# # You can try (test-expression e) or (show-C-expression e).
# # See file chap10f.scm for other possibilities.
start.chap10e : ${all-o}
	( echo "				(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")					" ; tee ) 			|  ${SCHEME}

# # test indepently a compiled file o/chap10e.c.
test.chap10e.c : ${all-o}
	cd o/${HOSTTYPE} ; 	${CC} ${CFLAGS} ../chap10e.c scheme.o schemelib.o -o chap10e &&	chap10e

# # chap10k.scm : CPS transformation, use schemeklib.c
# # Very long test but it does not fail on call/cc tests.
# # 837.20user 526.45system 30:42.24elapsed
long.test.chap10k :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10k ; else : ; fi
test.chap10k : o/${HOSTTYPE}/scheme.o
test.chap10k : o/${HOSTTYPE}/schemeklib.o
test.chap10k : src/chap10k.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(load \"src/chap10k.scm\")			(load \"src/chap10m.scm\")			(and (test-scheme10k \"src/scheme.tst\")	     (test-scheme10k \"src/chap10k.tst\")	     (test-scheme10k \"src/chap10e.tst\") )"	| ${SCHEME}

# # Test chap10k by direct interpretation		(obsolete)
test.chap10l : src/chap10l.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10b.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10d.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(load \"src/chap10k.scm\")			(load \"src/chap10m.scm\")			(load \"src/chap10l.scm\")			(and (test-scheme10b \"src/scheme.tst\")	     (test-scheme10b \"src/chap10k.tst\")	     (test-scheme10b \"src/chap10e.tst\") )"	| ${SCHEME}

# # as for various interpreters, try our usual bench.
chap10k.bench : o/${HOSTTYPE}/scheme.o
chap10k.bench : o/${HOSTTYPE}/schemeklib.o
chap10k.bench : src/chap5-bench.scm
	echo "						(load \"src/chap10a.scm\")				(load \"src/chap10c.scm\")				(load \"src/chap10g.scm\")				(load \"src/chap10e.scm\")				(load \"src/chap10h.scm\")				(load \"src/chap10f.scm\")				(load \"src/chap10k.scm\")				(load \"src/chap10m.scm\")				(set! *a.out* \"chap10k\")				(call-with-input-file \"src/chap5-bench.scm\" 		  (lambda (in) (test-expression (read in))) )"		| ${SCHEME}

	${TIME} o/${HOSTTYPE}/chap10k
# #0.04user0.03system 0:00.07elapsed 100%CPU(42avgtext+221avgdata 212maxresident)k
# #0inputs+1outputs (0major+9minor)pagefaults 0swaps

# # Generate the C code corresponding to the running example of chapter 10.
# # The C code will be left in o/chap10kex.c
chap10k.example : src/c/chap10kex.c
src/c/chap10kex.c : src/chap10ex.scm src/chap10e.scm
	echo "						(load \"src/chap10a.scm\")				(load \"src/chap10c.scm\")				(load \"src/chap10g.scm\")				(load \"src/chap10e.scm\")				(load \"src/chap10h.scm\")				(load \"src/chap10f.scm\")				(load \"src/chap10k.scm\")				(load \"src/chap10m.scm\")				(set! *cc+cflags* \"${CC} ${CFLAGS}\")			(call-with-input-file \"src/chap10ex.scm\"		   (lambda (in) (test-expression (read in))) )"		| ${SCHEME}

	size o/${HOSTTYPE}/chap10e
	emacs -batch -l el/c-indent.el
	mv o/chap10e.c src/c/chap10kex.c

# # chap10j.scm contains an initialization analysis. It can be grafted
# # to chap10e or chap10k without differences. As the others, it is
# # very long.

# # This test fails on continuations used out of their dynamic extent.
# # 595.30user 492.41system 24:49.56elapsed
long.dynext.test.chap10je :
	if ${YOU_HAVE_TIME} ; then ${MAKE} dynext.test.chap10je ; else : ; fi
dynext.test.chap10je : test.chap10je
test.chap10je : src/chap10j.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(load \"src/chap10j.scm\")			(and (test-scheme10e \"src/scheme.tst\")	     (test-scheme10e \"src/chap10e.tst\") 	     (test-scheme10e \"src/chap10j.tst\") )"	| ${SCHEME}

# # This one does not fail but lasts long...
# # 857.14user 529.60system 33:20.49elapsed
long.test.chap10jk :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10jk ; else : ; fi
test.chap10jk : src/chap10j.scm src/chap10p.scm
	echo "					(load \"src/chap10a.scm\")			(load \"src/chap10c.scm\")			(load \"src/chap10g.scm\")			(load \"src/chap10e.scm\")			(load \"src/chap10h.scm\")			(load \"src/chap10f.scm\")			(load \"src/chap10k.scm\")			(load \"src/chap10m.scm\")			(load \"src/chap10j.scm\")			(load \"src/chap10p.scm\")			(and (test-scheme10k \"src/scheme.tst\")	     (test-scheme10k \"src/chap10e.tst\") 	     (test-scheme10k \"src/chap10k.tst\") 	     (test-scheme10k \"src/chap10j.tst\") )"	| ${SCHEME}

# # Compare time between o/$HOSTTYPE/c10ex.c and c10kex.c
# # They have been modified from src/c/chap10[k]ex.c to repeat the
# # computation 10000 times so their duration can be better estimated.
# # Pay attention to the precise timing command.
compare.chap10 : o/${HOSTTYPE}/c10ex o/${HOSTTYPE}/c10kex
compare.chap10 :
	csh -c "time o/${HOSTTYPE}/c10ex"
	csh -c "time o/${HOSTTYPE}/c10kex"
bCFLAGS	= -I../../src/c -ansi -pedantic -O
o/${HOSTTYPE}/c10ex : src/c/c10ex.c ${all-o}
	cd o/${HOSTTYPE} ; ${CC} ${bCFLAGS} -o c10ex ../../src/c/c10ex.c 		scheme.o schemelib.o

o/${HOSTTYPE}/c10kex : src/c/c10kex.c ${all-o}
	cd o/${HOSTTYPE} ; ${CC} ${bCFLAGS} -o c10kex ../../src/c/c10kex.c 		scheme.o schemeklib.o

# # blaye% time o/${HOSTTYPE}/c10ex
# # (2 3)
# # 0.830u 0.270s 0:01.14 96.4% 3+170k 0+0io 0pf+0w
# # blaye% time o/${HOSTTYPE}/c10kex
# # (2 3)
# # 1.360u 0.360s 0:01.70 101.1% 3+247k 0+0io 0pf+0w

# # end of Test.mkf

# end of Dist.Imakefile

# ######################################################### Common entries

# # Clean or recursively clean directories.

clean ::
	-rm *~ .*~
rec.clean : clean
	@PWD=`pwd` ; export PWD					; \
	for d in `find . -type d -print`			; \
	  do ( cd $$d ; echo Cleaning $$d 			; \
	       ${MAKE} -f $$PWD/Makefile clean ) ; done

# # Create tags for editing sources with Gnu Emacs.

tags : TAGS
TAGS :
	etags */?*.scm

